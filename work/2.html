<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <title>
   Harvard CS152
  </title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="ie=edge" http-equiv="X-UA-Compatible"/>
  <link href="../favicon.6dad811d.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../init.dc7a44b8.css" rel="stylesheet"/>
  <link href="../work.b7675249.css" rel="stylesheet"/>
 </head>
 <body>
  <header id="nav-styling">
   <nav>
    <a class="logo-link" href="../index.html">
     <h1>
      The 500 Project
     </h1>
     <span>
     </span>
    </a>
    <small>
     <a class="info-link" href="../about.html" id="about">
      üëÄAbout
     </a>
     /
     <a class="info-link" href="../works.html" id="topics">
      üî•Topics
     </a>
     /
     <a class="info-link" href="../articles.html" id="articles">
      üìöArticles
     </a>
    </small>
   </nav>
  </header>
  <main id="main-container">
   <article id="work-container">
    <h1 id="work-title">
     Harvard CS152
    </h1>
    <h2 id="work-subtitle">
     Programming Languages
    </h2>
    <article id="work-content-container">
     <p>
      <img alt="" src="https://raw.githubusercontent.com/raymonddeng99/the500project/master/app/assets/cambridge.jpeg"/>
     </p>
     <p>
      <em>
       <strong>
        Motivation
       </strong>
      </em>
     </p>
     <p>
      This project is largely concerned with system design, but most of my job as a software engineer will likely be writing application-level code in an object-oriented style. I‚Äôm interested in a conceptual framework for correct software design flexible for changes by future developers.
     </p>
     <p>
     </p>
     <p>
      Jimmy Koppel notes that the most relevant field from programming language theory about thinking about software design is type theory, which is roughly be described as the study of small/toy programming languages (called ‚Äúcalculi‚Äù) designed to explore some kind of programming language feature. So I‚Äôm studying Benjamin Pierce‚Äôs Types and Programming Languages and using this course to supplement the textbook material. This is also the only course I could find that covered sub-structural type systems, which is a key part of Rust‚Äôs design.
     </p>
     <p>
     </p>
     <p>
      <em>
       <strong>
        Lectures
       </strong>
      </em>
     </p>
     <p>
      Small-step semantics
     </p>
     <p>
      Proofs by Induction
     </p>
     <p>
      Large-step semantics
     </p>
     <p>
      IMP: a simple imperative language
     </p>
     <p>
      Denotational semantics
     </p>
     <p>
      Lambda calculus
     </p>
     <p>
      IMP and denotational semantics
     </p>
     <p>
      Lambda calculus encodings and Recursion
     </p>
     <p>
      Definitional translations
     </p>
     <p>
      References and continuations
     </p>
     <p>
      Simply-typed lambda calculus Type soundness
     </p>
     <p>
      More types
     </p>
     <p>
      Type inference
     </p>
     <p>
      Parameteric Polymorphism, Records and Subtyping
     </p>
     <p>
      Curry-Howard isomorphism; Existential types
     </p>
     <p>
      Sub-structural type systems
     </p>
     <p>
      Algebraic structures
     </p>
     <p>
      Axiomatic Semantics and Hoare Logic
     </p>
     <p>
      Dependent types
     </p>
     <p>
      Proof tools
     </p>
     <p>
      Logic Programming
     </p>
     <p>
      Error Propagating Semantics
     </p>
     <p>
     </p>
     <p>
      <em>
       <strong>
        TaPL Chapters
       </strong>
      </em>
     </p>
     <p>
      Untyped Arithmetic Expressions
     </p>
     <p>
      An ML Implementation of Arithmetic Expressions
     </p>
     <p>
      The Untyped Lambda-Calculus
     </p>
     <p>
      Nameless Representation of Terms
     </p>
     <p>
      An ML Implementation of the Lambda-Calculus
     </p>
     <p>
      Typed Arithmetic Expressions
     </p>
     <p>
      Simply Typed Lambda-Calculus
     </p>
     <p>
      An ML Implementation of Simple Types
     </p>
     <p>
      Simple Extensions
     </p>
     <p>
      Normalization
     </p>
     <p>
      References
     </p>
     <p>
      Exceptions
     </p>
     <p>
      Subtyping
     </p>
     <p>
      Metatheory of Subtyping
     </p>
     <p>
      An ML Implementation of Subtyping
     </p>
     <p>
      Case Study: Imperative Objects
     </p>
     <p>
      Case Study: Featherweight Java
     </p>
     <p>
      Recursive Types
     </p>
     <p>
      Metatheory of Recursive Types
     </p>
     <p>
      Type Reconstruction
     </p>
     <p>
      Universal Types
     </p>
     <p>
      Existential Types
     </p>
     <p>
      An ML Implementation of System F
     </p>
     <p>
      Bounded Quantification
     </p>
     <p>
      Case Study: Imperative Objects, Redux
     </p>
     <p>
      Metatheory of Bounded Quantification
     </p>
     <p>
      Type Operators and Kindling
     </p>
     <p>
      Higher-Order Polymorphism
     </p>
     <p>
      Higher-Order Subtyping
     </p>
     <p>
      Case Study: Purely Functional Objects
     </p>
    </article>
   </article>
  </main>
  <script defer="" src="../init.ddb7c0df.js">
  </script>
 </body>
</html>